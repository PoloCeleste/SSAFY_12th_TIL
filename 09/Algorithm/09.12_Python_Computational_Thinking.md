# Computational Thinking

## 기초논리 & 수학

### 0. 서론 - 프로그래밍과 논리/수학

- 프로그래밍이 초보자에게 어렵게 느껴지는 2가지 이유

  1. 초보자에게 복잡해 보이는 프로그래밍 언어 문법, 복잡한 라이브러리 사용
  2. 논리(Hard Logic)

- 직관: 무의식적으로 즉각적인 사고과정. 명확한 논리적 추론 없이 결론에 도달하는 것

  - 경험, 감정, 잠재의식에 의존하는 사고 방식

- 논리: 명확한 규칙과 절차를 통해 사고를 전개하는 과정

  - 일련의 단계적 추론 과정을 통해 결론에 도달하는 것

- 논리에는 2가지가 존재

  - Hard Logic
    - 프로그래밍은 Hard Logic을 사용
    - Soft Logic으로 알고리즘을 이해하려고 하면 안됨
  - Soft Logic
    - 직관 사용 - 논리적 느낌을 주는 것
    - 장점: 익숙한 상황에서 빠름
    - 단점: 정확하지 않고, 강한 착각을 일으킬 수 있음

### 1. 논리와 증명

- 명제란?
  - 참 혹은 거짓을 명확히 판별할 수 있는 문장
  - 명령문, 권유문, 질문문 -> 참 거짓 평가가 불가 -> 명제 X
- 조건 명제: 두 명제 사이에 조건을 부여하는 표현

  - p -> q로 표현한다.
  - (전건) p: 조건이 되는 명제 (p라면)
  - (후건) q: 조건이 충족될 때 결과로 나오는 명제 (q이다.)

- 진리표(Truth Table)

  - 논리식이나 논리 연산의 모든 가능한 입력 조합과 그에 따른 출력을 보여주는 표

    |  p  |  q  | p -> q |
    | :-: | :-: | :----: |
    |  F  |  F  |   T    |
    |  F  |  T  |   T    |
    |  T  |  F  |   F    |
    |  T  |  T  |   T    |

    - 명제가 거짓이면, p -> q는 무조건 참이다.

    1. 역(Converse) : 조건 명제의 전건과 후건을 서로 바꾼 명제
       - q -> p
       - 조건 명제가 참이라도, 참이 아닐 수 있다.
       - 원래 조건 명제의 반대 방향으로 추론하고자 할 때 사용.
    2. 이(Inverse) : 조건명제의 전건과 후건을 각각 부정한 명제
       - ~p -> ~q
       - 만약 p가 아니면, q도 아니다.
       - 조건 명제가 참이더라도, 참이 아닐 수 있다.
       - 논리적으로 원래 명제와 부정된 상황에서 참인지 거짓인지 확인하는 데 사용
    3. 대우(Contrapositivie) : 조건명제의 전건과 후건을 서로 바꾸고, 각각 부정한 명제
       - ~q -> ~p
       - 만약 q가 아니면, p도 아니다.
       - 원래 조건명제와 항상 동일한 진리값을 가진다.
         - 대우가 참임을 증명하면 원래 명제도 참임(간접 증명)

- 증명

  - 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
  - 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
  - 증명에 대한 수많은 오해가 p->q를 p<->q와 혼동하는 것에서 일어남

- 증명 방법
  - 직접 증명: 조건에서 바로 결론을 도출하는 증명
  - 간접 증명(귀류법, 모순법): 결론이 거짓이라고 가정하여 모순을 유도하는 방식
  - 대우를 이용한 증명
  - 수학적 귀납법
    - 수학적 귀납법의 기본형: P(1)이 참이고, P(n)->P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참이다.
    - 수학적 귀납법의 강한 형태: P(1)이 참이고, P(1)⋀P(2)⋀...⋀P(n)->P(n+1)이 참이면 P(n)은 모든 자연수n에 대하여 참이다.

#### 참고

- 연산자 우선순위
  - ~ > ⋁, ⋀ > →, ↔
- 항진명제: 진리값이 항상 참
- 모순명제: 진리값이 항상 거짓
- 사건명제: 항진명제도 모순명제도 아닌 명제

### 2. 수와 표현

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k-1까지 표현 가능
- 어떤 경우든 최대 2^k가지의 값을 표현하는 것 가능
- 10진수로 k자리를 쓰면 10^k-1까지 표현이 가능한 것과 완전히 동일

<br>

- logn
  1. 2의 몇 제곱이 n이 되느냐의 답
  2. n을 표현하는데 몇 비트가 필요한가의 답
  3. 1로 시작해서 계속 두 배를 할 때 몇 번하면 n이 되느냐의 답
  4. n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답
  - 컴퓨터 분야에서의 로그의 밑은 항상 2

### 3. 집합과 조합론

#### 집합

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.

#### 조합론

- 조합론은 보통 경우의 수를 따지는 문제들을 말한다
- 조합의 개수는 C를 이용하여 표현하기도 하지만 (⁵₂)=10과 같은 괄호 표현을 더 많이 쓴다.

### 4. 기초 수식

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재한다.
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 시간이 얼마나 걸릴 지 예측할 수 있다.

### 5. 재귀

- 재귀란 자기자신을 호출하는 함수
- 함수는 입력이 있으며, 자기 자신과 동일한 입력으로 자신을 호출하면 끝나지 않고, 다른 입력으로 호출해야 끝낼 수 있다.
- 함수란 어떤 문제를 해결하는 방법을 코딩하는 것

### 6. 동적 프로그래밍

- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과값을 저장해두고 불러쓰는 것.(Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 저장할 수 있는 메모리가 있어야함
- 단순 재귀에서 저장된 값을 찾아보는 것도 가능하지만, 결과 값을 순서를 정해서 계산할 수도 있다.

- DP Fibonacci

  ```py
  Fibonacci(n)
      F[0]<-0
      F[1]<-1

      for i <- 2, i<=n, i<-i+1
          F[i]=F[i-1]+F[i-2]

      return F[n]
  ```
